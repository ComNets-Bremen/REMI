#ifndef FLEXOR_LOG
#define FLEXOR_LOG

#include "RssiDemoMessages.h"

/******************************************************************************** 
	 LOG READ WRITE AND ERASE FUNCTIONS
	 *******************************************************************************/
	//Log struct for reading 
	RssiMsg_t readlog_data;

//#ifdef LOG_ENABLED
	
	bool log_busy=FALSE;
	bool append_busy=FALSE;
	bool read_scheduled=FALSE;
	bool erase_scheduled=FALSE;
	bool serial_busy;
	
	message_t log_tos_data;
	
	// Log buffer for to store the incoming log if log write is busy
	//flexor_log_struct_t log_buffer[LOG_WRITE_BUFFER_SIZE];
	RssiMsg_t log_buffer[LOG_WRITE_BUFFER_SIZE];

	//index for tracking the buffer for writing the log
	uint8_t buffer_index;

	// tasks for the log read, erase and transmission of the data log read	
	task void transmitLogData();
	task void readLogData();
	task void eraseLogData();

	void flexor_log_init()
	{
	
		log_busy=FALSE;
		append_busy=FALSE;
		read_scheduled=FALSE;
		erase_scheduled=FALSE;
		buffer_index=0;
	}

	task void readLogData()
	{
		bool status;
		if(!log_busy)
		{
			status = call DataLogRead.read(&readlog_data,sizeof(RssiMsg_t));
			if(status == SUCCESS)
		    	{
				log_busy=TRUE;				
				//atomic printf("Read Log \n");	 
		   	}
		   	else
		    	{
				// if log is being written then again post reading the log as a task so that it will execute for sure
				post readLogData();
		    		//flexor_report_error(LOG_ERROR);
			}
		}
		else 
		{
			read_scheduled=TRUE;
			//printf("Read Scheduled\n");
		}
		//atomic printfflush();
	}
	task void eraseLogData()
	{
		if(!log_busy)
		{
					
			if(call DataLogWrite.erase()==SUCCESS)
			{	
				log_busy=TRUE;
				//printf("Erasing Log\n");
			}
			else
			{
				//printf("Error Erasing the Data Log\n");
				post eraseLogData();
	    			//flexor_report_error(LOG_ERROR);
			}
		}
		else
		{	
			erase_scheduled=TRUE;
			//printf("Erase Scheduled\n");
		}
		//atomic printfflush();		
	}

	/* DATA LOG TRANSMISSION*/

	task void transmitLogData()
	{
		
		RssiMsg_t* log_data = (RssiMsg_t*)(call SerialDataLogPacket.getPayload(&log_tos_data, (sizeof(RssiMsg_t))));
		bool status;

		/***copying the read log data into the log_data t transmit to the serial port****/
		memcpy(log_data, &readlog_data,(sizeof(RssiMsg_t)));
		
		// sending  the log data to the serial port  
		status = call SerialDataLogAMSend.send(AM_BROADCAST_ADDR,&log_tos_data, sizeof(RssiMsg_t));
        	if(status == SUCCESS)
        	{
        		serial_busy = TRUE;
			//printf("log transmit \n");
        	}
       		else if(status == EBUSY)
        	{
        		//printf("Network is Busy");
			post transmitLogData();
		}
        	else
        	{
        		//flexor_report_error(LOG_ERROR);
       		}
		//printfflush();
		
  	}
//#endif

	/** END OF DATA LOG TRANSMISSION**/
	void flexor_write_log(RssiMsg_t* writelog_data)
	{
//#ifdef LOG_ENABLED
		bool status;
		if(!append_busy)
		{
			if(buffer_index<LOG_WRITE_BUFFER_SIZE)
			{
				//atomic printf("buf writing\n");				
				memcpy(&log_buffer[buffer_index],writelog_data,sizeof(RssiMsg_t));
				buffer_index++;		
			}	
		}
		else
		{
			// do noting and drop the packet
		}
		
		if((buffer_index==LOG_WRITE_BUFFER_SIZE)&&(!log_busy))
		{
			/***** writing the data to the log storge of mote*****/
			//atomic printf("buf full\n");
			status = call DataLogWrite.append(&log_buffer,(LOG_WRITE_BUFFER_SIZE*sizeof(RssiMsg_t)));
			if(status == SUCCESS)
			{	
				append_busy=TRUE;
				log_busy=TRUE;
				buffer_index=0;
			}
			else
			{	
				//flexor_report_error(LOG_ERROR);
			}				
		}
		//atomic printfflush();		
//#endif
	}
				
	void flexor_read_log()
	{
//#ifdef LOG_ENABLED
		post readLogData();
//#endif
	}
	
	void flexor_erase_log()
	{
//#ifdef LOG_ENABLED
		post eraseLogData();		
//#endif
	}
	
	/********************************************************************************
	  EVENTS GENERATED BY LOG READ WRITE AND ERASE FUNCTIONS
	 *******************************************************************************/
//#ifdef LOG_ENABLED
	event void DataLogWrite.appendDone(void* buf, storage_len_t len,bool recordsLost, error_t err) 
	{
		if(err == SUCCESS)
		{	
			append_busy=FALSE;			
			log_busy=TRUE;
			call DataLogWrite.sync();
			//atomic printf("Data Written Success\n");			
		}
		else
		{
			//printf("Error Appending the Log\n");
			append_busy=FALSE;
			log_busy=FALSE;
	    		//flexor_report_error(LOG_ERROR);
		}
		//atomic printfflush();
	}

	event void DataLogRead.readDone(void* buf,storage_len_t len,error_t err)
 	{
		if((len == sizeof(RssiMsg_t)) && (buf == &readlog_data))
		{	
			/*sending the log data*/
			//atomic printf("Transmit data\n");
			log_busy=TRUE;
			post transmitLogData();	
		}
		else
		{
			log_busy=FALSE;
			read_scheduled=FALSE;
			if(len==0)
			{
			//	atomic printf("End of Reading the Log\n");
				if(erase_scheduled)
				{
					post eraseLogData();			
				}
			}
			
		}
		//atomic printfflush();
  	}
	event void DataLogWrite.eraseDone(error_t err) {
		if (err == SUCCESS)
		{
			log_busy=FALSE;
			erase_scheduled=FALSE;
		 	//atomic printf("Log Erased\n");
			if(read_scheduled)
				post readLogData();			
		}
		else
		{
			//flexor_report_error(LOG_ERROR);
		}
		//atomic printfflush();
	}


	event void DataLogRead.seekDone(error_t err) {
	}

	event void DataLogWrite.syncDone(error_t err) {
		log_busy=FALSE;
		append_busy=FALSE;
		//atomic printf("sync done");
		if(read_scheduled)
			post readLogData();
		else if (erase_scheduled)
			post eraseLogData();
		//atomic printfflush();
	}
	
	/********************************************************************************
	  END OF EVENTS GENERATED BY LOG READ WRITE AND ERASE FUNCTIONS
	 *******************************************************************************/
	/*#else
	
	void flexor_read_log()
	{}
	
	void flexor_erase_log()
	{}
	
	void flexor_write_log(flexor_log_struct_t* writelog_data)
	{}
	
	#endif*/
	
	
	/**************** SERIAL AM CONTROL START AND STOP DONE***************/
	
	event void SerialAMControl.startDone(error_t error)
	{
	
	}
  
 	event void SerialAMControl.stopDone(error_t error)
  	{
	
  	}
	
	/***** SERIAL DATA SEND DONE ******/

	//#ifdef LOG_ENABLED
	event void SerialDataLogAMSend.sendDone(message_t* msg, error_t error)
  	{
		if(&log_tos_data == msg)
		{
			serial_busy = FALSE;
			//printf("Log Data Message Sent Successfully \n");
			call SerialDataLogPacket.clear(msg);
    			if(call DataLogRead.read(&readlog_data,sizeof(RssiMsg_t)) != SUCCESS )
    			{
			    	 //printf("Error Reading the Log\n");
    			}
    			else
    			{
				read_scheduled=FALSE;
				log_busy=FALSE;
			} 
		}
		//printfflush();
  	}
	//#endif

		
	/********************************************************************************
	  END OF LOG READ WRITE AND ERASE FUNCTIONS

	 *******************************************************************************/
//#endif
#endif

